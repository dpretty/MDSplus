#include "CoherencyManager.h"
#include "ChannelListener.h"
#include "ChannelFactory.h"

#include <stdio.h>
#include <stdlib.h>


CoherencyManager::CoherencyManager(SharedDataManager *dataManager)
{
	this->dataManager = dataManager;
	channel = chanFactory.getChannel();
}

/* COHERENCY BEHAVIOUR
A single process on every machine hosting a cache serve cache coherency messages as follows:


1) Request for data: this is generated by a cache not owber and not warm willing to access the data. 
		The WHOLE data for the node is returned. 

		Message format: int nid
		Answer format: int numSlots; for each slot: int dataSize: int dimSize; char data[dataSize]; char dim[dimSize]

2) Ownership changed. Compare the current ownership timestamp with the passed timestamp: if the new timestamp
		is greater, or if it is equal and the ids of the new owner is greater that the current owner ids, 
		update ownership information. If the node is warm, return 1 and read the WHOLE data for that node. Otherwise return 0.

		Message format: int nid; int timestamp, char ownerIdx 
		Answer format: char ack. 
		If ACK != 0, a new message containing the whole data set is returned as before. 
	
	 
3) Data message: this message is originated by the current owner and the node is warm in this cache. It contains a
		single data slot which can be either the last appended slot or the unique data slot if the datum is not timed.

		Message Format: int nid; char append; char ackRequest; int dataSize; int dimSize; char data[dataSize]; char dim[dimSize];
		If ackRequest return a ACK byte contyaining 1		


In every process making data access:


When data is read, checkRead needs to be called first. checkRead does nothing if there is no owner, or the cache is 
the current owner or if the node is warm in this cache. Otherwise, the WHOLE data set is requested to the current owner.

When data is (over)written, checkWrite needs to be called afterwards. If the cache is the current owner, the (single or last) data 
slot is sent to all the warm (for that node) caches. If the cache is not the current owner, an ownership message is broadcasted
with an incremented timestamp and the cache becomes the current owner.
When data is appended, checkRead is called first, and checkWrite is called after.

*/




void CoherencyManager::handleMessage(ChannelAddress *addr, char *buf, int bufLen, char type)
//Handle messages from other caches in the system. This is run by a single process on every machine.
{
	switch(type)
	{
		case REQUEST_DATA_TYPE:
		{
			int nid = channel->toNative(*(unsigned int *)buf);
			handleRequestDataMsg(nid, addr);
			break;
		}
		case OWNERSHIP_TYPE:
		{
			int nid = channel->toNative(*(unsigned int *)buf);
			int timestamp = channel->toNative(*(unsigned int *)(&buf[sizeof(int)]));
			char ownerIdx = buf[2 * sizeof(int)];
			handleOwnershipMsg(nid, timestamp, ownerIdx, addr);
			break;
		}
		case DATA_TYPE:
		{

//Data message format: each data slot is preceded by its size. 
//If timed a dimension slot, preceded by its size follows the data slot
			int nid = channel->toNative(*(unsigned int *)buf);
			bool append = (buf[sizeof(int)])?true:false;
			bool ackReq = (buf[sizeof(int) + 1])?true:false;
			handleDataMsg(nid, append, ackReq, &buf[2 + sizeof(int)], addr);
			break;
		}
		default: printf("Unsupported message type received: %d\n", type);
	}
}


//Manages request for data: read the whole data slot set  and send it. 
//The returned message contains the data slots.
void CoherencyManager::handleRequestDataMsg(int nid, ChannelAddress *addr)
{
	int numSlots;
	int isTimed;
	int i,j;

	dataManager->getSharedInfo(nid, &numSlots, &isTimed);
	int *dataSizes = new int[numSlots];
	int *dimSizes = new int[numSlots];
	char **data = new char *[numSlots];
	char **dims = new char *[numSlots];
	dataManager->getMultipleSharedData(nid, data, dataSizes, dims, dimSizes);

	int outLen = sizeof(int);
	for(i = 0; i < numSlots; i++)
	{
		outLen += 2 * sizeof(int); //space for slot size and dim size
		outLen += dataSizes[i];
		outLen += dimSizes[i];
	}
	char *outMsg = new char[outLen];
	*(unsigned int *)outMsg = channel->fromNative(numSlots);
	for(i = 0, j = sizeof(int); i < numSlots; i++)
	{
		*(unsigned int *)&outMsg[j] = channel->fromNative(dataSizes[i]);
		*(unsigned int *)&outMsg[sizeof(int)+j] = channel->fromNative(dimSizes[i]);
		j+= 2* sizeof(int);
		memcpy(&outMsg[j], data[i], dataSizes[i]);
		j+= dataSizes[i];
		if(dimSizes[i] > 0)
		{
			memcpy(&outMsg[j], dims[i], dimSizes[i]);
			j+= dimSizes[i];
		}
	}
	channel->sendMessage(addr, outMsg, outLen, DATA_TYPE);

	//Free Stuff
	for(i = 0; i < numSlots; i++) //data and dim slots ale allocated via malloc
	{
		free(data[i]);
		if(dimSizes[i] > 0)
			free(dims[i]);
	}
	delete [] outMsg;
	delete [] dataSizes;
	delete [] dimSizes;
	delete [] data;
	delete [] dims;
}


void CoherencyManager::handleOwnershipMsg(int nid, int timestamp, char ownerIdx, ChannelAddress *addr)
{

	int prevOwnerIdx;
	bool isOwner;
	bool isWarm;
	int prevTimestamp;
	dataManager->getCoherencyInfo(nid, isOwner, prevOwnerIdx, isWarm, prevTimestamp);

	if((timestamp < prevTimestamp )|| //It is an outdated message
		((timestamp == prevTimestamp) && ownerIdx < prevOwnerIdx)) //It is a concurrent write, but the sender has lowe priority

	{
		char answer = 0; //Simple ACK, does nothing
		channel->sendMessage(addr, (char *)&answer, 1, OWNERSHIP_ACK_TYPE);
		return;
	}

		
	dataManager->setOwner(nid, ownerIdx, timestamp);

	char answer = 0; //Simple ACK, no warm
	if(isWarm)
		answer = 1;
	else
		answer = 0;

	channel->sendMessage(addr, (char *)&answer, 1, OWNERSHIP_ACK_TYPE);

	if(isWarm)
	{
		char retType;
		int dataMsgLen;
		char *dataBuf = channel->receiveMessage(addr, &dataMsgLen, &retType);
		if(dataBuf)
		{
			int numSlots = channel->toNative(*(unsigned int *)dataBuf);
			getData(nid, numSlots, false, &dataBuf[sizeof(int)]);
			delete[] dataBuf;
		}
		answer = 1;
		channel->sendMessage(addr, (char *)&answer, 1, OWNERSHIP_ACK_TYPE);
	}
}


void CoherencyManager::getData(int nid, int numSlots, bool append, char *buf)
{
/*Get the data, possibly containing more than one data slots
	Message format: 
	- int num slots
	for each slot:
		int dataSize;
		int dimSize;
		char data[dataSize];
		char dim[dimSize]
*/
	if(!append)
		dataManager->resetSharedData(nid);
	int j = 0;
	for(int i = 0; i < numSlots; i++)
	{
		int dataSize = channel->toNative(*(unsigned int *)&buf[j]);
		int dimSize = channel->toNative(*(unsigned int *)&buf[j+sizeof(int)]);
		if(dimSize > 0)
			dataManager->setCurrDim(nid, &buf[j + 2 * sizeof(int) + dataSize], dimSize);
		dataManager->appendSharedData(nid, &buf[j+sizeof(int)], dataSize);
		j+= dataSize + dimSize + 2 * sizeof(int);
	}
}


void CoherencyManager::handleDataMsg(int nid, bool append, bool ackRequest, char *buf, ChannelAddress *addr)
{
	getData(nid, 1,append, buf);
	if(ackRequest)
	{
		char answer = 1;
		channel->sendMessage(addr, (char *)&answer, 1, DATA_ACK_TYPE);
	}
}


//Make sure data is up-to-date with latest cache version before reading
void CoherencyManager::checkRead(int nid)
{
	int ownerIdx;
	bool isOwner;
	bool isWarm;
	int timestamp;

	dataManager->getCoherencyInfo(nid, isOwner, ownerIdx, isWarm, timestamp);
	if(isOwner || ownerIdx == -1 || isWarm) 
		return;

	ChannelAddress *addr = chanFactory.getAddress(ownerIdx);
	//Request whole data set
	channel->sendMessage(addr, (char *)&nid, sizeof(int), REQUEST_DATA_TYPE);
	int dataBufLen;
	char retType;
	char *dataBuf = channel->receiveMessage(addr, &dataBufLen, &retType); 
	if(dataBuf)
	{
		int numSlots = channel->toNative(*(unsigned int *)dataBuf);
		getData(nid, numSlots, false, &dataBuf[sizeof(int)]);
		delete[] dataBuf;
	}
}

void CoherencyManager::checkWrite(int nid)
{
	int ownerIdx;
	bool isOwner;
	bool isWarm;
	int timestamp;
	int dataLen;

	char *prevWarmList;
	int numPrevWarm;

	dataManager->getCoherencyInfo(nid, isOwner, ownerIdx, isWarm, timestamp, prevWarmList, numPrevWarm);
	if(!isOwner) //It was not owner, update all nodes, possibly sending the whole data item (for warm nodes)nodes
	{
		int numAddresses;
		timestamp++;
		ChannelAddress **addresses = chanFactory.getOtherAddresses(numAddresses);
		char outBuf[2*sizeof(int)+1];
		*(unsigned int *)outBuf = channel->fromNative(nid);
		*(unsigned int *)(&outBuf[sizeof(int)]) = channel->fromNative(timestamp);
		outBuf[2 * sizeof(int)] = chanFactory.getThisAddressIdx();

		char *fullDataBuf = getFullDataBuffer(nid, dataLen);
		int numWarm = 0;
		char *warmList = new char[numAddresses];
		for(int i = 0; i < numAddresses; i++)
		{
			channel->sendMessage(addresses[i], outBuf, 2 * sizeof(int)+1, OWNERSHIP_TYPE);
			int retBufLen;
			char retType;
			char *retBuf = channel->receiveMessage(addresses[i], &retBufLen, &retType); 
			if(retBuf[0]) //if node in remote cache is warm
			{
				warmList[numWarm++] = i;
				channel->sendMessage(addresses[i], fullDataBuf, dataLen, DATA_TYPE);
				int ackLen;
				char ackType;
				char *ackBuf = channel->receiveMessage(addresses[i], &ackLen, &ackType); 
				if(ackBuf)
					delete[]ackBuf;
			}
			delete []retBuf;
		}
		dataManager->setCoherencyInfo(nid, true, -1, false, timestamp, warmList, numWarm);
		delete [] warmList;
		delete[]fullDataBuf;
	}
		
	else //It is owner, send last data slot to all warm nodes
	{
		if(numPrevWarm > 0)
		{
			int msgLen;
			char *updateDataMsg = getUpdateDataMsg(nid, msgLen);
			for(int i = 0; i < numPrevWarm; i++)
			{
				ChannelAddress *currAddr = chanFactory.getAddress(prevWarmList[i]);
				channel->sendMessage(currAddr, updateDataMsg, msgLen, DATA_TYPE);
				char ackType;
				int ackLen;
				char *ackBuf = channel->receiveMessage(currAddr, &ackLen, &ackType);
				if(ackBuf)
					delete[]ackBuf;
			}
			delete [] updateDataMsg;
		}
	}
	delete [] prevWarmList;
}


//Build a buffer containing a set of data slot.
//Format: int numSlot, for every slot int dataSize; int dimSize; char data[dataSize]; char dim[dimSize]
char *CoherencyManager::getFullDataBuffer(int nid, int &dataLen)
{	
	int numSlots, isTimed, i, j;
	dataManager->getSharedInfo(nid, &numSlots, &isTimed);
	char **data = new char *[numSlots];
	char **dims = new char *[numSlots];
	int *sizes = new int[numSlots];
	int *dimSizes = new int[numSlots];

	dataManager->getMultipleSharedData(nid, data, sizes, dims, dimSizes);
	dataLen = sizeof(int);
	for(i = 0; i < numSlots; i++)
		dataLen += 2 * sizeof(int) + sizes[i] + dimSizes[i];

	char *outBuf = new char[dataLen];
	*(unsigned int *)outBuf = channel->fromNative(numSlots);

	for(i = 0, j = sizeof(int); i < numSlots; i++)
	{
		*(unsigned int *)(&outBuf[j]) = channel->fromNative(sizes[i]);
		j+= sizeof(int);
		*(unsigned int *)(&outBuf[j]) = channel->fromNative(dimSizes[i]);
		j+= sizeof(int);
		memcpy(&outBuf[j], data[i], sizes[i]);
		j+= sizes[i];
		if(dimSizes[i] > 0)
		{
			memcpy(&outBuf[j], dims[i], dimSizes[i]);
			j+= dimSizes[i];
		}
	}
	//free stuff
	for(i = 0; i < numSlots; i++)
	{
		delete [] data[i];
		if(dimSizes[i] > 0)
			delete [] dims[i];
	}
	delete []data;
	delete [] data;
	delete [] sizes;
	delete [] dimSizes;
	return outBuf;
}



//Build a data message containing the last data slot.
//Format: int nid, char append; char ackRequest (true for now); int dataSize; int dimSize; char data[dataSize]; char dim[dimSize];
char *CoherencyManager::getUpdateDataMsg(int nid, int &msgLen)
{
	int numSlots, isTimed, i;
	dataManager->getSharedInfo(nid, &numSlots, &isTimed);
	char **data = new char *[numSlots];
	char **dims = new char *[numSlots];
	int *dataSizes = new int[numSlots];
	int *dimSizes = new int[numSlots];

	dataManager->getMultipleSharedData(nid, data, dataSizes, dims, dimSizes);

	msgLen = sizeof(int) + 2 + dataSizes[numSlots - 1] + dimSizes[numSlots - 1];
	char *outMsg = new char[msgLen];
	*(unsigned int *)outMsg = channel->fromNative(nid);
	outMsg[sizeof(int)] = (numSlots > 1);
	outMsg[sizeof(int) + 1] = 1;
	*(unsigned int *)(&outMsg[sizeof(int) + 2]) = channel->fromNative(dataSizes[numSlots - 1]);
	*(unsigned int *)(&outMsg[sizeof(int) + 2 + sizeof(int)]) = channel->fromNative(dimSizes[numSlots - 1]);
	memcpy(&outMsg[sizeof(int) + 2 + 2*sizeof(int)], data[numSlots-1], dataSizes[numSlots - 1]);
	if(dimSizes[numSlots - 1] > 0)
		memcpy(&outMsg[sizeof(int) + 2 + 2*sizeof(int)+dataSizes[numSlots-1]], dims[numSlots-1], dimSizes[numSlots - 1]);
	//free stuff
	for(i = 0; i < numSlots; i++)
	{
		delete [] data[i];
		if(dimSizes[i] > 0)
			delete [] dims[i];
	}
	delete []data;
	delete [] data;
	delete [] dataSizes;
	delete [] dimSizes;
	return outMsg;
}


void CoherencyManager::startServer()
{
	channel->attachListener(this, REQUEST_DATA_TYPE);
	channel->attachListener(this, OWNERSHIP_TYPE);
	channel->attachListener(this, DATA_TYPE);
	channel->connectReceiver(chanFactory.getThisAddress());
}





			


