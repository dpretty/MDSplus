#!/bin/sh
#
#
# Manage MDSplus rpm packaging
#
# Usage: pkg mode options
#        mode == add remove list
#
# Modes:
#
# add: Add module to a rpm subpackage
#
#   Usage:    pkg add module-name package-name [-R]
#   examples: pkg add TreeAddNode.c kernel
#             pkg add treeshr/* kernel
#
# remove: Remove module from an rpm subpackage
#
#   Usage:    pkg remove module-name package-name [-R]
#   examples: pkg remove TreeAddNode.c kernel
#             pkg remove treeshr/* kernel
#
# list:   List modules in an rpm subpackage
#
#   Usage:    pkg list package-name
#   examples: pkg list kernel
#             pkg list NONE  (lists all modules not in any package)
#             pkg list ALL   (lists all modules and the package(s) they are in)
#
# get_release: Get current rpm release of an rpm subpackage
#
#   Usage:    pkg get_release package-name flavor
#   examples: pkg get_release camac stable
#             pkgrel-stable-3-0-2-el5
#
# check_release: Check to see if rpm is up to date
#
#   Usage:    pkg check_release package-name flavor
#   examples: pkg check_release camac stable
#             tdi/camac/CamXandQ.fun current stable revision is 1.1 while rpm revision is 1.2
#       Returns the string "ok" if up to date otherwise lists module revisions not in latest rpm
#
list_none()
{
  awk '/Repository revision/ {F=substr($4,24,length($4)-25);PKG="";} /pkg_/ {PKG=substr($1,5) " "} /====/ {if (length(F) > 0 && length(PKG) == 0) print F; F=""}' $1 | sort
}

list_all()
{
  awk '/Repository revision/ {F=substr($4,24,length($4)-25);PKG=""} /pkg_/ {PKG=PKG substr($1,5) " "} /====/ {if (length(F) > 0 ) { if (length(PKG) == 0) PKG="None"; print F "   " PKG}; F=""}' $1 | sort
}

list_pkg()
{
  awk '/Repository revision/ {F=substr($4,24,length($4)-25)} /pkg_'$2'/ {print F}' $1 | sort
}

case $1 in
  "")
  cat - <<EOF
Usage: $0 pgkadd <module or directory (no wildcards)> <package-name>

          Assigns package dependency to a module or directory tree of modules.

       $0 pkgremove <module or directory (no wildcards)> <package-name>

          Remove package dpendency to a module or directory tree of modules.

       $0 list

          Generates a module package summary in html format.

       $0 list none

          Generates a list of modules that currently do not have a package depency
          assigned.

       $0 list <package-name>

          Generate a list of modules that updates to the package depend on.

       $0 list all

          Generate a module package summary in text format.
      
EOF
  ;;
  pkgadd)
    if [ ! -r `dirname $0`/../rpm/subpackages/$3 ]
    then
      echo Package $3 does not exist
      exit
    fi
    for mod in `find $2`
    do
      pushd `dirname $mod` >/dev/null
      m=$(basename $mod)
      if [ ! -d $m ]
      then
        if ( cvs status $m 2>/dev/null | grep /mdsplus/repos > /dev/null )
        then
          echo "Adding `pwd`/$m to package $3"
          cvs -Q tag -F pkg_$3 $m
        fi
      fi
      popd > /dev/null
    done
  ;;
  pkgremove)
    if [ ! -r `dirname $0`/../rpm/subpackages/$3 ]
    then
      echo Package $3 does not exist
      exit
    fi
    for mod in `find $2`
    do
      pushd `dirname $mod` >/dev/null
      m=$(basename $mod)
      if [ ! -d $m ]
      then
        if ( cvs status $m 2>/dev/null | grep -v Attic | grep /mdsplus/repos > /dev/null )
        then
          echo "Removing `pwd`/$m from package $3"
          cvs -Q tag -d pkg_$3 $m
        fi
      fi
      popd > /dev/null
    done
  ;;
  list)
    case $2 in
    none)
       tmpstatus=$(mktemp)
       $0 get_cvs_status > $tmpstatus
       list_none $tmpstatus
       rm -f $tmpstatus
    ;;
    all)
       tmpstatus=$(mktemp)
       $0 get_cvs_status > $tmpstatus
       list_all $tmpstatus
       rm -f $tmpstatus
    ;;
    "")
       tmpstatus=$(mktemp)
       $0 get_cvs_status > $tmpstatus
       echo "<head><title>MDSplus Packaging Information - Sources</title></head>"
       echo "<h2>Modules sorted by module name</h2>"
       echo "<table border=\"1\"><tr><td><b>Module</b></td><td><b>Package(s)</b></td></tr>"
       awk '/Repository revision/ {F=substr($4,24,length($4)-25);PKG=""} /pkg_/ {PKG=PKG substr($1,5) "<br/>"} /====/ {if (length(F) > 0 ) { if (length(PKG) == 0) PKG="None"; print "<tr><td>" F "</td><td><a href=\"#" PKG "\">" PKG "</a></td></tr>"}; F=""}' $tmpstatus | sort
       echo "</table>"
       echo "<h2>Modules sorted by package name</hd>"
       echo "<table border=\"1\"><tr><td><b>Package</b></td><td><b>Module(s)</b></td></tr>"
       awk '/Repository revision/ {F=substr($4,24,length($4)-25);PKG=""} /pkg_/ {PKG=substr($1,5)} /====/ {if (length(F) > 0) { if (length(PKG) == 0) PKG="None"; print "<tr><td><a href=\"#" PKG "\">" PKG "</a></td><td>" F "</td></tr>"}; F=""}' $tmpstatus | sort
       echo "</table>"
       rm -f $tmpstatus
       for pkg in rpm/subpackages/*
       do
         pkgname=$(basename $pkg)
         if [ "$pkgname" == "CVS" ]
         then
           continue
         fi
         size=$(ls -l $pkg | awk '{print $5}')
         echo "<a name=\"$pkgname\"><h2>$pkgname</h2></a></br>"
	 if [ $size -eq 0 ]
         then
           echo "Not currently packaged"
         else
           echo "<pre>"
	   cat $pkg
	   echo "</pre>"
	 fi
       done
    ;;
    *)
       if [ -r $(dirname $0)/../rpm/subpackages/$2 ]
       then
         tmpstatus=$(mktemp)
         $0 get_cvs_status > $tmpstatus
	 list_pkg $tmpstatus $2
	 rm -f $tmpstatus
       else
         echo "No such package /$2/"
       fi
    ;;
    esac
  ;;
  get_cvs_status) #internal use
    dirn=$(dirname $0)
    cd $dirn/..
    cvs -q status -Rv 2>/dev/null
  ;;
  get_dist) #internal use
    rpmbuild --showrc | awk '/[[:space:]]dist[[:space:]]/ {print $3}'
  ;;
  get_version) #internal use
    if [ -z "$3" ]
    then
       file=$(mktemp)
       $0 get_cvs_status > $file
       keep=""
    else
       file=$3
       keep="yes"
    fi
    awk '/release.h,v/ {V="yes"} /pkgver-'$2'/ {if (V=="yes"){A[0]="";split($1,A,"-");print A[3] "." A[4];exit;}}' $file
    if [ -z "$keep" ]
    then
      rm -f $file
    fi
  ;;
  get_release)
    # pkg get_release package-name flavor [cvs status filename]
    # prints current release for a package release for the specified flavor and platform distribution
    # rpm/subpackages/package-name will normally have a tag: pkgrel-flavor-versionMajor-versionMinor-release-platform
    # for example: pkgrel-stable-3-0-2-rhel5
    # this is used to identify the release number for the current version and platform
    if [ -z "$4" ]
    then
       file=$(mktemp)
       $0 get_cvs_status > $file
       keep=""
    else
       file=$4
       keep="yes"
    fi
    version=$($0 get_version $3 $file)
    version=$(echo $version | awk '{v[0]=split($1,v,".");print v[1] "-" v[2]}')
    dist=$($0 get_dist)
    dist=$(echo $dist | awk '{d[0]=split($1,d,".");print d[2]}')
    awk '/subpackages\/'$2'/ {R="yes"} /pkgrel-'$3'-'$version'-[[:digit:]]-'$dist'/ {if (R=="yes") {print $1;exit;}} /====/ {R="no"}' $file 
    if [ -z "$keep" ]
    then
      rm -f $file
    fi
  ;;
  check_release) #internal use
    # pkg check_release package-name flavor [cvs status filename]
    # prints "ok" if all modules of this package contain a tag pkgrel-flavor-versionMajor-versionMinor-release-platform
    if [ -z "$4" ]
    then
       file=$(mktemp)
       $0 get_cvs_status > $file
       keep=""
    else
       file=$4
       keep="yes"
    fi
    release=$($0 get_release $2 $3 $4)
    if [ -z release ]
    then
      echo "RPM out of data: No release for this package, flavor and platform"
    else
      update=$(awk '/Repository revision/ {F=substr($4,24,length($4)-25);CURREV=$3} /pkg_'$2'/ {IN_PACKAGE="yes";} /'$release'/ {IN_RELEASE="yes"; RELREV=substr($3,0,length($3)-1)} /'$3'/ {if ($1=="'$3'"){CURREV=substr($3,0,length($3)-1)}} /===/ {if (IN_PACKAGE=="yes") {if (IN_RELEASE != "yes") {print F " not in latest rpm"} else if (RELREV != CURREV) {print F " current '$3' revision is " CURREV " while rpm revision is " RELREV}}; IN_PACKAGE="no"; IN_RELEASE="no";}' $file)
      if [ -z "$update" ]
      then
        echo ok
      else
        echo "$update"
      fi
    fi
    if [ -z "$keep" ]
    then
      rm -f $file
    fi
  ;;
  makeRpms)
     # pkg makeRpms flavor
     # example: pkg makeRpms stable
     file=$(mktemp)
     $0 get_cvs_status > $file
     flavor="$2"
     version=$($0 get_version $flavor $file)
     kitname="mdsplus-${version}"
     echo version=$version kitname=$kitname
     if !(grep topdir $HOME/.rpmmacros >/dev/null 2>&1)
     then
	 echo "%_topdir $HOME/rpm" > $HOME/.rpmmacros
	 mkdir -p $HOME/rpm/BUILD
	 mkdir -p $HOME/rpm/RPMS
	 mkdir -p $HOME/rpm/SOURCES
	 mkdir -p $HOME/rpm/SPECS
	 mkdir -p $HOME/rpm/SRPMS
     fi
     tdir=$(mktemp -d -p $HOME)
     if [ -z "$tdir" ]
     then
       echo "Error creating temporary directory"
       rm -f $file
       exit
     fi
     echo "using $tdir"
     pushd $tdir > /dev/null
     cvs -d :pserver:MDSguest@www.mdsplus.org:/mdsplus/repos -Q checkout -r $flavor -f mdsplus
     mv mdsplus $kitname
     tar zcf $HOME/rpm/SOURCES/${kitname}.tag.gz --exclude CVS $kitname
     mkdir buildroot
     cat - > rpm.spec <<EOF
Name: mdsplus
Version: $version
Release: $($kitname)/devscripts/pkg get_release all "$flavor" | awk -F- '{print $5}')
License: BSD Open Source
Summary: The MDSplus Data System
Group: Applications/Acquisition
Source: ${kitname}.tar.gz
Prefix: /usr/local
BuildRoot: $tdir/buildroot
AutoReqProv: yes
EOF
     for pkg in $(ls $kitname/rpm/subpackages | grep -v "~" | grep -v "#")
     do
       if [ "$(ls -l $kitname/rpm/subpackages/$pkg | awk '{print $5}')" != "0" ]
       then
         echo "requires: mdsplus-${pkg}" >> rpm.spec
       fi
     done
     cat - >> rpm.spec <<EOF
%description
Main libraries and programs to get MDSplus operational

%prep
%setup -q


%build
if [ "%_target" != "i686-linux" ]
then
  ./configure --exec_prefix=$RPM_BUILD_ROOT/usr/local/mdsplus --bindir=$RPM_BUILD_ROOT/usr/local/mdsplus/bin32 --libdir=$RPM_BUILD_ROOT/usr/local/mdsplus/lib32 --enable-nodebug --target=i686-linux --disable-java
make clean
make
  ./configure --exec_prefix=$RPM_BUILD_ROOT/usr/local/mdsplus --bindir=$RPM_BUILD_ROOT/usr/local/mdsplus/bin64 --libdir=$RPM_BUILD_ROOT/usr/local/mdsplus/lib64 --enable-nodebug
  make clean
  make
else
  ./configure --exec_prefix=$RPM_BUILD_ROOT/usr/local/mdsplus --bindir=$RPM_BUILD_ROOT/usr/local/mdsplus/bin32 --libdir=$RPM_BUILD_ROOT/usr/local/mdsplus/lib32 --enable-nodebug --target=i686-linux
  make clean
  make
fi


%install

make install
if [ "%_target" |= "i686-linux" ]
then
  cp -r bin32 $RPM_BUILD_ROOT/usr/local/mdsplus/
  cp -r lib32 $RPM_BUILD_ROOT/usr/local/mdsplus/
  cp -r uid32 $RPM_BUILD_ROOT/usr/local/mdsplus/
else
  ln -sf bin32 $RPM_BUILD_ROOT/usr/local/mdsplus/bin
  ln -sf lib32 $RPM_BUILD_ROOT/usr/local/mdsplus/lib
fi
cp -r matlab $RPM_BUILD_ROOT/usr/local/mdsplus/
cp -r php    $RPM_BUILD_ROOT/usr/local/mdsplus/
cp -r pixmaps $RPM_BUILD_ROOT/usr/local/mdsplus/

%clean
rm -rf $RPM_BUILD_ROOT

%post 
$RPM_INSTALL_PREFIX/mdsplus/rpm/post_install_script

%postun

MDSPLUS_DIR=`cat /etc/.mdsplus_dir`
$MDSPLUS_DIR/local/mdsplus_post_uninstall_script



%files



%changelog
* Wed Aug 29 2000 Basil P. DUVAL <basil.duval@epfl.ch>
- version 1.0

EOF
     for pkg in $(ls $kitname/rpm/subpackages | grep -v "~" | grep -v "#")
     do
       if [ "$(ls -l $kitname/rpm/subpackages/$pkg | awk '{print $5}')" != "0" ]
       then
         release=$($kitname/devscripts/pkg get_release $pkg $flavor)
         if [ -z "$release" -o ]
         then
           $release=0
         elif [ "$(kitname/devscripts/pkg check_release $pkg $flavor)" != "ok" ]
         then
           let release=$release+1
         fi
         sed s/--RELEASE--/$release/ $kitname/rpm/subpackages/$pkg >> rpm.spec
       fi
     done
     
     popd > /dev/null
#     rm -Rf $tdir/$kitname
#     rm -Rf $tdir/buildroot
#     rm -f $tdir/rpm.spec
#     rmdir $tdir
#     rm -f $file
  ;;
  *)
     echo "Unknown mode /$1/"
     echo
     $0
  ;;
esac
